\documentclass[12pt]{article}

\usepackage{sbc-template}
\usepackage{graphicx,url}
\usepackage{comment}
\usepackage{listings}
\usepackage{color}
\usepackage{soul}
\usepackage[brazil]{babel}   
\usepackage[latin1]{inputenc}  

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.9,0.9,0.9}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{ %
  backgroundcolor=\color{mygray},  % choose the background color
  basicstyle=\footnotesize,        % size of fonts used for the code
  breaklines=true,                 % automatic line breaking only at whitespace
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  keywordstyle=\color{blue},       % keyword style
  stringstyle=\color{mymauve},     % string literal style
}
     
\sloppy

\title{Implementando um sistema de informação para análise de dados usando SPA e MVC client-side}
%\title{Implementando um sistema de informação de análise de dados focado no front-end usando SPA e MVC client-side}
%\title{ Estudo de caso de um sistema de informação de estatística usando arquitetura\\MVC client-side}

\author{
	Rafael Andrade de Oliveira\inst{1},
	Diogo Lucas\inst{1}
}

\address{
	Pós-Graduação em Tecnologias Aplicadas a Sistemas de Informação com Métodos Ágeis
	\\Centro Universitário Ritter dos Reis (UniRitter)
	\\Caixa Postal 1355 -- 90.840-440 -- Porto Alegre -- RS -- Brasil 
	\email{
		eu.rafa@gmail.com,
		diogolucas@gmail.com
	}
}

\begin{document} 

	\maketitle

\begin{abstract}

	The present paper reports a case study of the implementation of an information system for data analysis, aiming to demonstrate the analysis of multi-dimensional data cubes on the client side.
	This case study also includes an evaluation of the proposed architecture for the development of information system, focused on the front end, involves the concept SPA (Single-Page Application) and the MVC (Model-View-Controller) client-side.
	In Article scope are detailed in the characteristics and differences of this information and its system architecture, as well as the form of manipulation of data cube.

\end{abstract}
     
\begin{resumo} 

	O presente trabalho relata um estudo de caso referente a implementação de um sistema de informação para análise de dados, tendo como objetivo demonstrar a realização de análises sobre cubos de dados multi-dimensionais no lado cliente.
	Este estudo de caso também abrange uma avaliação da arquitetura proposta para o desenvolvimento deste sistema de informação que, focado no front-end, envolve o conceito SPA (Single-Page Application) e o modelo MVC (Model-View-Controller) client-side.
	No escopo do artigo serão detalhadas das características e diferenciais deste sistema de informação e sua arquitetura, bem como a forma de manipulação sobre cubo de dados.
	
\end{resumo}

\section{Introdução}\label{introducao}

	Este artigo irá apresentar a implementação de um sistema de informação para análise de dados com foco no \emph{front-end}, trazendo consigo uma proposta de arquitetura de \emph{software} moderna voltada para a \emph{web}.
	O objetivo desta implementação é possibilitar a realização de análises sobre cubo de dados diretamente no lado cliente, evitando requisições HTTP (HyperText Transfer Protocol) adicionais, trocas de mensagens ou consumo de serviços \emph{web} a cada interação do usuário ao aplicar filtros e segmentações.
	
	A escolha do tema justifica-se pela importância da análise de dados para tomada de decisão aliada a competitividade no mercado corporativo e também a relevância do uso de uma arquitetura de \emph{software} moderna, que acompanhe a evolução da Internet e linguagens de programação.

	Em relação a análise de dados, percebemos que atualmente muitas empresas estão investindo em soluções de apoio de decisão como BI (Business Intelligence) e BigData, entendendo que a análise do seu próprio negócio e o levantamento de indicadores é importante para alcançar melhores resultados.
	Sobre a arquitetura de \emph{software}, sabe-se da necessidade de evolução constante para acompanhar as inovações tecnológicas, além de mudanças comportamentais e culturais da sociedade.
	O surgimento de novos dispositivos móveis como tablets e a modernização de celulares (\emph{smartphones}) exigem avanços nos aplicativos fazendo com que a arquitetura de \emph{software} se envolvesse por exemplo com mobilidade, computação na nuvem (\emph{cloud computing}) e design responsivo.
	Além disso, o volume de pessoas com acesso a Internet e a milhares de aplicativos estimula a competitividade, fazendo com que a arquitetura tenha também a preocupação com UX (User eXperience), sem esquecer necessidades óbvias como desempenho e escalabilidade.
	
	Para servir de modelo da implementação de um sistema de informação para análise de dados sobre uma arquitetura de \emph{software} com o foco no lado cliente, foi desenvolvido o sistema \textbf{Statz}.
	Antes de apresentar a arquitetura proposta e a implementação do Statz, descritas na seção \ref{statz}, é interessante alinhar alguns pontos facilitando o melhor entendimento do sistema e da arquitetura proposta.
	As próximas seções abordam conceitos, tecnologias e \emph{frameworks} utilizados na prova de conceito da arquitetura através do sistema de informação Statz.

\section{Referencial teórico}\label{referencial-teorico}

	Nesta seção estão descritos os conceitos e as tecnologias envolvidas no desenvolvimento do Statz e na arquitetura proposta.
	Com isso, ficará mais fácil compreender a proposta deste artigo e a relação dos conceitos com a arquitetura do Statz.

	\subsection{OLAP}
	
		Quando falamos de análise de dados, um leque de opções e níveis de análise podem aparecer.
		Em um contexto mais analítico e interativo, voltado para tomada de decisão rápida sobre grandes volumes de dados, o cenário se estreita a análises sobre cubo de dados multi-dimensional.

		Nesse sentido, entra a tecnologia OLAP (On-Line Analytical Processing) que significa processamento analítico online.
		OLAP nada mais é do que uma tecnologia de banco de dados otimizado na forma de cubo de dados multidimensional, diferente de um banco de dados relacional baseado em linhas e coluas.

	\subsection{Conceitos de cubo de dados}

		Um cubo de dados é uma estrutura de dados que combina dados em várias dimensões (multidimensional), uma hierarquia em vários níveis de granularidades como demonstrado na figura \ref{fig:cubo-dados}.

		\begin{figure}[ht]
		\centering
		\includegraphics[width=.5\textwidth]{1.jpg}
		\caption{Representação de um cubo de dados multidimensional}
		\label{fig:cubo-dados}
		\end{figure}

		Normalmente possui dados históricos agregados e sumarizados, facilitando o acesso as informações.
		É chamado de cubo devido ao seu conceito complexo, sem relação com o sentido matemático onde cubo é uma geometria de lados iguais.

		Um modelo de dados multidimensional normalmente é representado no formato de estrela (Star Schema), composto por tabelas de fato e dimensões como mostra a figura \ref{fig:modelo-estrela}.

		\begin{figure}[ht]
		\centering
		\includegraphics[width=.5\textwidth]{1.jpg}
		\caption{Exemplo de um modelo de dados multidimensional no formato de estrela}
		\label{fig:modelo-estrela}
		\end{figure}

		É importante destacar alguns conceitos de cubo de dados.
		Entre eles destaco fato, medida e dimensão.
		Fato representa uma coleção de dados relacionados que podem servir a análise.
			Uma tabela fato possui os dados agregados baseados em uma entidade e seus relacionamentos.

		\subsubsection{Medida}
		
			Medidas correspondem a atributos de um fato cubo de dados.
			Normalmente que representam indicadores, pois são dados quantitativos pré-calculados.

		\subsubsection{Dimensão}

			As dimensões de um cubo de dados representam visões ou contextos diferentes sobre um fato.
			É como se fosse uma coordenada de análise sobre o cubo de dados multidimensional.
			Existe uma dimensão especial relativa ao tempo (temporal) que caracteriza uma data/hora.
			Para exemplificar, dimensões para uma medida "Total de vendas" poderiam ser "cliente", "cidade", "data", "produto" e etc, que nada mais são do que visões diferentes sobre uma determinada medida.

		\subsubsection{Membro}

			Membros correspondem a elementos usados para determinar o dado de uma dimensão.
			Por exemplo "mês Fevereiro" e "ano 2014" são membros de uma dimensão temporal.
			Em algumas situações, podem existir membros calculados.

		\subsubsection{Hierarquia}

			Este componente apenas organiza o cubo de dados, definindo níveis de agregação e granularidade do cubo, relacionando membros a dimensões.

	\subsection{Operações sobre cubo de dados}

		Abaixo estão detalhadas algumas operações básicas realizadas sobre cubos de dados multidimensionais.

		\subsubsection{Drill down}

			\emph{Drill down} é a operação utilizada para detalhar mais o dado.
			Segundo \cite{bi-enfoque}, é a capacidade de chegar a mais detalhes em um ou vários níveis.

		\subsubsection{Roll up}

			\emph{Roll up} representa a operação utilizada para abstrair mais os dados, reduzindo o nível de detalhamento atual.
			O funcionamento é exatamente contrário a operação anterior.
			Quando maior o nível de granularidade, menor o nível de detalhamento.

		\subsubsection{Slice}

			A operação utilizada para a redução do universo de dados do cubo chama-se \emph{slice}.
			Na prática, filtra ou fatia o cubo de dados multidimensional.

		\subsubsection{Dice}

			Outra operação que reduz o universo de dados do cubo é a \emph{dice}, porém esta operação descarta parte do cubo de dados. 

	\subsection{JavaScript}
	
		JavaScript é considerada a linguagem de programação da Internet.
		Criada inicialmente para os navegadores Netscape, atualmente está presente em todos os navegadores de Internet.
		As páginas de Internet são baseadas em três tecnologias: HTML (HyperText Markup Language), CSS (Cascading Style Sheets) e JavaScript.
		Após muito tempo, HTML e CSS sofreram atualizações trazendo respectivamente nas versões HTML5 e CSS3 avanços consideráveis para a geração de páginas de Internet.
		
		Por outro lado, o JavaScript evolui de forma significativa com a criação de novos frameworks, tornando-se, a cada dia, mais poderoso e utilizado entre os desenvolvedores \cite{ang-prat}.
		O JavaScript provê uma maior interatividade com a página, por exemplo respondendo a eventos de botões, validação de campos de formulário, manipulação de elementos.
		
		Atualmente existem milhares de bibliotecas JavaScript para fins diversos e para usá-las é necessário apenas declará-las na página com a \emph{tag} HTML $<$script$>$ como mostra a figura \ref{fig:js}.
		Algumas destas bibliotecas são amplamente utilizadas, como a popular biblioteca chamada jQuery, famosa pela sua facilidade na manipulação de elementos DOM (Document Object Model), estilos CSS, eventos HTML, tratamento de requisições usando AJAX (Asynchronous JavaScript and XML) e ainda de forma compatível com a maioria dos navegadores e respectivas versões.
	
		\begin{figure}[ht]
		\centering
		\includegraphics[width=.7\textwidth]{javascript-inclusao-script.jpg}
		\caption{Exemplo de inclusão de uma biblioteca JavaScript em uma página HTML}
		\label{fig:js}
		\end{figure}
	
	\subsection{JSON}
	
		Uma notação derivada da linguagem JavaScript chamada JSON (JavaScript Object Notation) vem ganhando popularidade nos últimos anos.
		Criada por Douglas Crockford, JSON é uma estrutura de dados auto-descritiva, associativa e fácil de ler como demonstrado na figura \ref{fig:formato-json}.
		
		\begin{figure}[ht]
		\centering
		\includegraphics[width=.4\textwidth]{json-formato.jpg}
		\caption{Exemplo de estrutura de dados no formato JSON}
		\label{fig:formato-json}
		\end{figure}
	
		O JSON é um formato de serialização de dados com base em literais de JavaScript \cite{js-guide}.
		Este formato de dados tem sido bastante utilizado no desenvolvimento de aplicações \emph{web} e serviços REST (REpresentational State Transfer), em substituição ao formato XML (eXtensible Markup Language) que é mais verboso como se pode perceber no comparativo representado na figura \ref{fig:js-xml-comparativo}.
		
		\begin{figure}[ht]
		\centering
		\includegraphics[width=1\textwidth]{json-comparativo-xml.jpg}
		\caption{Comparativo entre os formatos JSON e XML}
		\label{fig:js-xml-comparativo}
		\end{figure}
	
	\subsection{MVC}\label{mvc}
	
		A busca constante pela melhor forma de desenvolvimento de \emph{software} provoca uma série de estudos. 
		Muitos deles resultaram na criação dos chamados Padrões de Projeto (Design Patterns), que servem de modelos arquiteturais para resolverem problemas comuns de desenvolvimento.
		Estes padrões focam no reaproveitamento de soluções, seguindo alguns princípios como SOC (Separation Of Concerns), DRY (Don't Repeat Yourself), KISS (Keep It Simple Stupid) que guiam os desenvolvedores e arquitetos de \emph{software} em relação a separação de responsabilidades, não repetir ou querer reinventar a roda e manter códigos simples. 
		Foram pensados, testados e aprimorados pro programadores experientes, dando a confiança necessária para o seu reuso.
		
		A grande evolução no desenvolvimento \emph{web} veio com a recomendação do uso do padrão arquitetural MVC (Model-View-Controller) \cite{intro-arq-des-sw}.
		Este modelo visa a organização e a padronização da arquitetura de \emph{software}, separando a arquitetura em três camadas como mostra a figura \ref{fig:0}.
		
		\begin{figure}[ht]
		\centering
		\includegraphics[width=.5\textwidth]{1.jpg}
		\caption{Desenho do modelo MVC e a interação entre as camadas}
		\label{fig:0}
		\end{figure}
		
		No modelo MVC cada um dos componentes tem responsabilidade bem definida.
		Model é o componente responsável pela representação do modelo de dados e mecanismo de persistência e View é responsável pela apresentação e interação com o usuário final. Já o Controller é o mecanismo intermediário responsável por receber e responder a eventos e ações entre os componentes Model e View.
		MVC é um padrão de projeto arquitetônico que incentiva a organização de uma melhor aplicação através de uma separação de interesses \cite{lng-js-dp}.
	
	\subsection{MVC client-side}\label{mvc-client-side}
	
		MVC client-side nada mais é do que o modelo MVC descrito na seção \ref{mvc} aplicado no lado cliente (\emph{client-side}).
		Muitos desenvolvedores consideram MVC como o modelo ideal de arquitetura de \emph{software}.
		Mesmo assim, este modelo de arquitetura vem sofrendo variações.
		Uma vez que o modelo (Model) e a apresentação (View) são essenciais para os sistemas, estas variações ocorrem no componente intermediário (Controller), dando lugar a novos modelos de arquitetura conhecidos como a família MV* ou MVW (Model-View-Whatever).

	\subsection{Single-Page Application}\label{spa}

		Single-Page Application (SPA) é uma abordagem atual utilizada em páginas de Internet consideradas "ricas".
		Como o próprio nome diz, significa ter a aplicação em uma única página tendo o seu conteúdo é carregado dinamicamente.
		Essa abordagem traz uma melhor experiência ao usuário, a medida que evita a troca ou refresh de página, e além disso evita a carga completa da página, o que pode também ser visto como uma melhora de desempenho.

	\subsection{MVP}\label{mvp}
		
		MVP (Model-View-Presenter) possui um mecanismo derivado do padrão  MVC, diferenciando-se apenas no conceito.
		Neste padrão, Presenter é a camada intermediária com o conhecimento das extremidades View e Model, tendo função semelhante ao Controller do padrão MVC.
		A camada Presenter é encarregada de atualizar a camada View quando a camada Model sofre alterações e também encarregada de sincronizar a camada Model em relação a View.

	\subsection{MVVM}

		\hl{Pendente...}
		MVVM (Model-View-ViewModel)

		\hl{Pendente...}
		Binding

\section{Status quo}

	A ideia desta seção é comentar a respeito de ferramentas existentes que oferecem soluções semelhantes ou que tenham relação com o presente artigo e o sistema de informação implementado.

	\subsubsection{API olap4j}

	O olap4j é uma API escrita em Java usada para o acesso a dados de cubos multidimensionais. Esta API é uma especialização das especificações 3 e 4 da API JDBC (Java Database Connectivity), portanto o olap4j é conhecido como o JDBC para OLAP.

	\subsubsection{Mondrian}

	Mondrian é um motor de análise OLAP escrito em Java.
	Com ele é possível construir soluções de BI, utilizando seu motor para análises sobre cubo de dados multidimensionais.
	É parte do pacote Pentaho BI, uma solução de BI bastante conhecida.

	Ao trabalhar com bancos de dados relacionais, a linguagem padrão para consultas é a SQL (Structured Query Language).
	O Mondrian realiza consultas sobre cubo de dados usando MDX (MultiDimensional eXpressions), que é considerado o SQL para OLAP.

	\subsubsection{Saiku}

	O Saiku é uma ferramenta para análise dinâmica de dados em cubos de dados multimensionais.
	Com essa ferramenta é possível cruzar informações de dimensões e medidas e visualizar os resultados em tabelas e gráficos.
	Tudo de forma fácil e prática, arrastando elementos (\emph{"drag and drop"}) para a análise no lugar desejado, como linha e coluna.
	Ainda é possível aplicar filtros sobre a análise realizada.

	\subsubsection{HyperCube}\label{sec:hypercube}
	
		HyperCube é uma biblioteca escrita em JavaScript que proporciona a criação de cubos de dados multi-dimensional, permite a aplicação de filtros e agregações, gerando dados estatíscos para fins de análise.
		\emph{Open source} sob licença Apache 2.0, o HyperCube está publicado no GitHub, onde está descrito como um banco de dados OLAP leve escrito em JavaScript, útil para qualquer aplicação que precise extrair métricas para propósitos de gráficos dinâmicos.
		
		A estrutura de dados interpretada pelo HyperCube é um mapa no formato JSON, onde seus registros contém tempo, fatos e medidas como mostra a figura \ref{fig:ex-mapa-json}.
		Esta estrutura de dados é convertida em um cubo de dados pesquisável, ou seja, apto a ser filtrado e consumido por funções matemáticas. A figura \ref{fig:cmd-js-cubo-hypercube} mostra o trecho de código JavaScript que realiza a geração do cubo de dados.
		
		\begin{figure}[ht]
		\centering
		\includegraphics[width=1\textwidth]{hypercube-mapa.jpg}
		\caption{Exemplo de um mapa de dados no formato JSON no formato compreendido pelo HyperCube}
		\label{fig:ex-mapa-json}
		\end{figure}

		\begin{figure}[ht]
		\centering
		\includegraphics[width=.8\textwidth]{hypercube-cubo.jpg}
		\caption{Código JavaScript responsável pela transformação do mapa em um cubo de dados do HyperCube}
		\label{fig:cmd-js-cubo-hypercube}
		\end{figure}
		
		\subsubsection{HyperCube API}
			
			O HyperCube fornece algumas funções para trabalhar com o cubo de dados e obter as informações para análise. As mais relevantes são:
			
			\begin{description}
			\item[count] Retorna o tamanho do cubo de dados, ou seja, a quantidade de objetos.
			\item[getFactNames] Retorna uma lista com os fatos contidos no cubo de dados.
			\item[getValues] Retorna uma lista com os valores distintos contidos em um determinado fato
			\item[slice] Retorna um cubo de dados filtrado a partir de fatos
			\item[sliceDates] Retorna um cubo de dados filtrado com dados entre duas datas
			\item[dice] Retorna um cubo de dados resultante da exclusão de objetos a partir de fatos
			\item[merge] Retorna a mescla um cubo de dados com outro cubo de dados
			\item[sum] Retorna a soma das medidas no cubo
			\item[avg] Retorna a média das medidas no cubo
			\item[topSum] Retorna as maiores somas das medidas no cubo
			\item[serialize] Transforma o cubo de dados no formato JSON
			\item[deserialize] Cria o cubo de dados a partir de um objeto no formato JSON
			\end{description}

	\subsection{Frameworks client-side}

	\hl{Pendente...}

	\subsubsection{Ember.js}

	\hl{Pendente...}

	\subsubsection{Backbone.js}	

	\hl{Pendente...}

	\subsubsection{AngularJS}

		AngularJS é um \emph{framework} MVC \emph{client-site} de bastante destaque criado pela da empresa Google.
		Em seu site, está descrito como 
		AngularJS é construído sobre a ideologia de que a programação declarativa deve ser usada para construção de interfaces e componentes, enquanto que a programação imperativa é excelente para escrever as regras de negócio \cite{col-front-end}.
		
		\hl{Pendente...} link com MVVM / MVW / MV*

		\hl{Pendente...} Controladores

		\hl{Pendente...} Modelos

		\hl{Pendente...} Escopo

		\hl{Pendente...} Diretivas

		\hl{Pendente...} Filtros

\section{Tomada de decisão}

	Esta seção aborda as escolhas realizadas para o desenvolvimento do projeto deste artigo, mencionando as justificativas das decisões após avaliações e algumas comparações entre as ferramentas e \emph{frameworks} relacionados.

	\subsection{Front-end da aplicação}

		Considerando que a solução proposta é uma aplicação \emph{web} codificada em HTML, com mecanismo Javascript envolvendo modelo de dados no formato JSON, após uma avaliação de ferramentas de mercado, optou-se pela utilização do \emph{framework} AngularJS.

		Entre os fatores determinantes para essa decisão estão o mecanismo próprio (\emph{engine templating}), o tamanho e dependências do AngularJS e o paradigma SPA.
		Além disso, o fato do \emph{framework} ter sido desenvolvido pela Google e experiências positivas do autor utilizando o mesmo contribuíram para a escolha, fazendo com que o \emph{framework} Durandal fosse descartado na comparação por ser bastante semelhante e do mesmo nível do AngularJS em relação a MVVM (\emph{data binding}) e SPA.

		A codificação utilizando o AngularJS é feita através de \emph{tags} e diretivas como se fosse uma extensão do próprio HTML, enquanto a codificação utilizando os demais lembram mais outras linguagens \emph{server-side} como ASP e Velocity do que HTML, uma vez que o Backbone.js é integrado com Underscore.js e o Ember.js possui dependência do Handlebars (que já é uma extensão do Mustache).
		Particularmente, alguns trechos de código do Backbone.js e do Ember.js me lembram respectivamente sintaxes das linguagens ASP e Velocity.

	\subsection{Análise sobre o cubo de dados}

		Uma vez que a proposta deste artigo é focada na análise diretamente no lado cliente, a opção foi modelar os dados no formato JSON, não importando a origem da leitura dos mesmos.
		O importante é poder trabalhar com os dados no Javascript, ignorando outros fatores como requisições HTTP, consumo de serviços REST e Data Warehouse.
		Para a montagem do cubo de dados em Javascript, sem dependência de outras APIs ou servidores de aplicação, a solução encontrada foi utilizar a API do Hypercube.
		Outras opções seriam mais indicadas para um BI mais robusto ou para trabalhar os dados no lado servidor.

\section{Descrição da solução}\label{descricao-da-solucao}

	A solução será descrita nesta seção, apresentando os detalhes da arquitetura e do sistema de informação implementado para estudo de caso deste artigo, que chama-se Statz.
	Além da teoria sobre análise de dados, serão mostrados detalhes da implementação, bem como o funcionamento das análises e as telas do sistema.

	\subsection{Statz}\label{statz}

		O Statz é uma aplicação \emph{web} no conceito de página única (\emph{single-page}) que serve para auxiliar a análise de dados estatísticos, manipulando dados em tempo real diretamente no \emph{front-end}.
		Tem como característica possibilitar esta análise sobre cubos de dados multi-dimensionais (OLAP), portanto através de filtros e segmentações o Statz apresenta os dados para análise através de \emph{dashboards}.

		\subsubsection{Apresentação}\label{statz-apresentacao}

			Esta seção apresenta a interface visual do sistema de informação Statz em sua tela inicial (figura \ref{fig:statz-interface}), onde é possível conhecer o logo do Statz, posicionado no cabeçalho à esquerda, e os links para as visões distintas de análise localizados na parte superior à direita.
			As páginas de análise, podem possuir uma área para filtros à esquerda, permitindo que o usuário realize as segmentações desejadas.

			\begin{figure}[ht]
			\centering
			\includegraphics[width=1\textwidth]{statz-interface.png}
			\caption{Interface do sistema, mostrando a primeira página de análise}
			\label{fig:statz-interface}
			\end{figure}

			O \emph{design} da aplicação, bem como indicadores ou gráficos, além de apresentar corretamente as informações devem mostrar os dados de forma objetiva e atrativa para possibilitar uma análise mais rápida e assertiva.

		\subsubsection{Universo de dados}\label{statz-universo-de-dados}

			Para servir de exemplo da análise de dados usando sistema Statz, foi escolhida uma base de dados de histórico de copas do mundo de futebol, fornecida pelo site da FIFA (Fédération Internationale de Football Association) como mostra a figura \ref{fig:site-fifa}.
			O Statz trabalha com os dados no lado cliente, para isso precisa carregá-los como um objeto JavaScript do tipo \emph{array}, no formato JSON.

			\begin{figure}[ht]
			\centering
			\includegraphics[width=.5\textwidth]{1.jpg}
			\caption{Estatísticas de copas do mundo disponibilizados no site da FIFA}
			\label{fig:site-fifa}
			\end{figure}
	
		\subsubsection{Arquitetura}\label{statz-arquitetura}

			A arquitetura do Statz é moderna, sendo desenvolvida no modelo MVC \emph{client-side}, mais precisamente o modelo MVVM com o uso do \emph{framework} AngularJS no \emph{front-end} da aplicação.
			Como o foco da solução é a manipulação dos dados diretamente no \emph{front-end}, optou-se por trabalhar com dados de exemplo fixos (\emph{hard-coded}), não desviando a atenção do escopo do presente artigo.
			Dessa forma, a aplicação não precisa buscar os dados, eles já estão presentes em um objeto Javascript no formato JSON e darão origem ao cubo de dados gerado através da API do HyperCube.
			Para que isso ocorra, é necessário que o objeto Javascript esteja em uma estrutura de dados predefinida contendo o momento do dado, fatos e medidas conforme é demonstrado na figura \ref{fig:fifa-dados-json}.
			Só assim, o HyperCube consegue interpretar e deserializar o objeto, montando o cubo de dados e disponibilizando o mesmo para ser filtrado e calculado também em Javascript.

			\begin{figure}[ht]
			\centering
			\includegraphics[width=.5\textwidth]{1.jpg}
			\caption{Dados de copas do mundo obtidas junto a FIFA, no formato JSON}
			\label{fig:fifa-dados-json}
			\end{figure}			

			Uma vez gerado o cubo de dados, o Statz consegue aplicar funções de estatística do HyperCube sobre o cubo, extraindo os indicadores que são apresentados nos \emph{dashboards} da aplicação.
			Além dos indicadores, os valores carregador na montagem dinâmica dos filtros também são extraídos a partir da API do HyperCubo, porém não são operações de estatística.

			Embora a principal característica do Statz esteja na sua ideia de arquitetura e mecanismo de análise (seção \ref{statz-mecanismo-de-analise}), a \emph{interface} da aplicação é também um ponto importantíssimo.
			É no \emph{front-end} que são montados os filtros de análise e \emph{dashboards} com dados e indicadores consolidados, lembrando \textbf{Model} e \textbf{View} se mantém sincronizados em tempo real, devido ao paradigma MVVM do AngularJS.
			
\begin{comment}
==========================================================================================
= FALA DA ORIGEM DOS DADOS EM BANCO, QUE PODERIAM SER DADOS DINÂMICOS OU GERADOS POR ETL =
==========================================================================================

Vale salientar que ss dados poderiam ser obtidos através de um DBMS (DataBase Management System), em português SGBD (Sistema de Gerenciamento de Banco de Dados), no tradicional banco de dados relacional ou em banco de dados NoSQL (Not Only SQL) que é um banco de dados não-relacional, mais flexível e de alta performance.
Em uma abordagem mais profissional, é interessante trabalhar com os dados de um DW (Data Warehouse), onde o modelo de dados é desnormalizado, normalmente os dados já foram transformados, agrupados e agregados por uma ferramenta de ETL (Extract, Transform, Load) deixando-os prontos para serem apresentados.

o lado servidor só é necessário se a origem dos dados for dinâmica por exemplo tabelas de banco de dados que sofrem atualizações constantes.
\end{comment}


\begin{comment}
==========================================================================================
= CLIENTE/SERVIDOR - NODE.JS - REST =
==========================================================================================

Diferente de aplicações cliente-servidor que trabalham basicamente com troca de mensagens via requisições HTTP e outras tecnologias, como o Node.JS, processam o JavaScript no lado servidor.
Basicamente, o Statz realiza apenas requisições para a inclusão das bibliotecas JavaScript utilizadas na página.
Para importar os dados e trabalhar as análises, busca um objeto JavaScript no formato JSON para a geração do cubo de dados multi-dimensional.
Os dados precisam ser carregados no JavaScript da página (\emph{client-side}), portanto devem ser extraídos de uma requisição adicional para um arquivo, caso os dados sejam estáticos, ou extraídos de uma requisição a um serviço REST que retornará os dados no 	formato JSON esperado.

Com os dados no lado cliente, o Statz já pode montar o cubo de dados multi-dimensional e manipular os dados. 
Para isso, utiliza a da API (Application Programming Interface) JavaScript do HyperCube, que disponibiliza algumas funções permitindo que se extraia informações do cubo de dados, relacionada tanto a fatos quanto medidas.
É dessa forma que o Statz acessa os dados e consegue criar os possíveis filtros e análises iniciais para apresentar ao usuário de forma visual através de gráficos e \emph{dashboards}, interagindo com o usuário através da seleção de dados dos filtros na página.
\end{comment}

		\subsubsection{Mecanismo de análise}\label{statz-mecanismo-de-analise}

			O mecanismo de análise se dá através da aplicação de operações de estatística sobre o cubo de dados extraindo dados para apresentar na tela.
			Cada página de análise possui um conjunto de análise específica, onde os dados são extraídos de acordo com o contexto da página de análise.

			Entenda como conjunto de análise o contexto de dados multidimensional, ou seja, fatos, dimensões e medidas relacionadas com a análise que são segmentadas na tela.
			As páginas de análise atualmente disponibilizadas são: Histórico, Ranking e País.
			Estas páginas de análise serão detalhadas a seguir e ficará mais claro seus respectivos contextos de análise.

			Ao abrir uma página de análise, por padrão é carregado o seu \emph{dashboard} e seus filtros, caso exista.
			O \emph{dashboard} nada mais é do que os dados do cubo de dados consolidados em indicadores.
			Os filtros, são os possíveis valores que podem ser usados para segmentar as medidas.
			Exemplos de indicadores são: total de vitórias, total de empates e total de derrotas.
			Exemplos de filtros são: ano, País e continente.
			Sendo assim, podemos segmentar os indicadores através dos filtros.
			
			Na prática, a visão inicial do indicadores é geral, pois não possuem filtros.
			Ao aplicar um filtro, os indicadores serão automaticamente atualizados, para considerar o filtro aplicado e assim restringir o universo de dados do cubo de dados da respectiva análise.
			Limpando os filtros, os indicadores são atualizados novamente, voltando ao estado original.

		\subsubsection{Análise histórica}

			A tela inicial do Statz é uma visão histórica das informações de jogos das copas do mundo, onde são apresentados os dados estatísticos calculados a partir do cubo de dados.
			Nela constam as informações de vitórias, empates, derrotas, gols a favor e gols contra, além do número de jogos.

			Estas informações são mapeadas no cubo de dados como \textbf{measures} (medidas).
			Os filtros possíveis, mapeados como \textbf{facts} (fatos), são o ano, o país e o continente.
			Através deles, é possível segmentar a análise sobre as informações do cubo de dados.

			A figura \ref{fig:statz-historico} apresenta a tela de histórico com alguns filtros selecionados à esquerda (realçados em amarelo) e na área principal mostra os dados já filtrados considerando os respectivos filtros.
			O resumo do filtro aplicado é: dados de copas do mundo do ano de 2006, do continente americano, mas apenas os Países Argentina e Brasil.

			A API do Hypercube possibilita filtrar o cubo de dados com a função \textbf{slice} passando um mapa de filtros com os valores de cada "fato" como "ano", "pais" e "continente".
			Inicialmente, como não há filtros selecionados, nenhuma função é aplicada, fazendo com que seja considerado todo o universo de dados contido no cubo de dados.
			Se quisermos filtrar por mais de um ano, pais ou continente, o resultado será um cubo de dados vazio.
			A explicação é simples: uma vez que os dados de histórico no detalhe sempre estão relacionados a algum ano específico, apenas de um país, que por sua vez pertence a um determinado continente.
			
			Portanto para agrupar os dados o Statz usa a função \textbf{dice}, passando também um mapa de filtros com valores de "fato".
			Esta função gera um novo cubo de dados desconsiderando a presença de tais filtros.
			Como esta tela já possui quais são os filtros selecionados, o Statz aplica a função \textbf{dice} nos valores não selecionados, obtendo o resultado esperado para demonstrar na tela.

			\begin{figure}[ht]
			\centering
			\includegraphics[width=1\textwidth]{statz-historico.png}
			\caption{Tela de histórico do Statz apresentando dashboards com os filtros aplicados}
			\label{fig:statz-historico}
			\end{figure}
				
		\subsubsection{Análise de ranking}

			A tela de ranking é mais simples que a anterior. Como se pode ver na figura \ref{fig:statz-ranking}, a mesma não possui filtros e apenas mostra uma relação de Países ordenadas por pontuação, ou seja, em primeiro lugar o País de melhor particição em todas as copas do mundo considerando a pontuação de vitórias e empates, e assim por diante até os Países de pior participação.

			O cubo de dados contém no detalhe o histórico de todos os Países em todas as participações.
			O que o Statz faz para criar o ranking é sumarizar os dados que dão origem a pontuação, dado calculado em tempo de execução considerando as medidas "vitorias" e "empates". 
			Vale ressaltar que a pontuação foi contabilizada considerando 3 (três) pontos por vitória e 1 (um) ponto por empate, ignorando o fato de a FIFA ter alterado a regra pontuação de vitória ao longo do tempo.

			Com a pontuação calculada um novo cubo de dados é gerado pelo Statz tendo em sua estrutura o País como fato e a pontuação como medida, o que resulta no mapeamento da pontuação de cada País.
			Aplicando a função \textbf{topSum} da API do Hypercube, passando o fato "pais" e a medida "pontos", temos os Países ordenados pela pontuação gerando assim o ranking apresentado na tela.

			\begin{figure}[ht]
			\centering
			\includegraphics[width=1\textwidth]{1.jpg}
			\caption{Tela de ranking do Statz}
			\label{fig:statz-ranking}
			\end{figure}

		\subsubsection{Análise específica de um País}

			Na tela de País é possível realizar uma análise focada em um determinado País, sem a interferência de outros dados relacionados, como mostra a figura \ref{fig:statz-pais}.
			Isso possibilita uma comparação entre um País e outro, sobre a participação dos mesmos nas copas do mundo.

			O Statz nesta tela aguarda o usuário realizar a escolha do País, para filtrar o cubo de dados e apresentar as informações do País.
			Mediante a seleção do País, o sistema aplica a função \textbf{slice} da API do Hypercube, passando um mapa de filtros.
			No caso, apenas o fato "pais" é passado como filtro. Isso faz com que seja gerado um novo cubo de dados, contendo apenas os dados do País selecionado.

			Com os dados do País, o sistema apresenta na área principal os dados do País para que seja realizada a análise.
			Alterando o filtro para outro País, o processo se repete mostrando novos dados, possibilitando a comparação entre Países.

			\begin{figure}[ht]
			\centering
			\includegraphics[width=1\textwidth]{1.jpg}
			\caption{Tela para análise especifica de um País}
			\label{fig:statz-pais}
			\end{figure}

\section{Próximos passos}

	A solução pode evoluir bastante ainda em alguns aspectos, tanto na parte de negócio com a inclusão de novos contextos de análise quanto na parte técnica em diversos aspectos.
	Por exemplo, o \emph{front-end} poderia melhorar a identidade visual e incorporar gráficos de vários tipos para melhor análise dos indicadores e com possibilidade de \emph{drill down}, poderia implementar um controle de acesso com login e senha para proteger o acesso aos dados, além de possibilitar exportar os dados da análise para o formato de planilha ou imagem.

	Na questão dos dados que atualmente são fixos, seria interessante avaliar o uso de um DW e pensar em automatizar a carga dos mesmos com alguma ferramenta de ETL, adaptando o sistema para um ambiente mais profissional (corporativo) onde a atualização dos dados se faz necessária com periodicidade às vezes até diária.
	Nesse caso, o arquivo Javascript seria atualizado diariamente.
	Lembrando que não as análise são sobre dado histórico (BI/Big Data), não devem ser em tempo real.

	Já pensando em carregar os dados em tempo de execução, penso que o melhor caminho seria evoluir para que o sistema consuma um serviço REST através de uma requisição AJAX.
	Esse serviço seria responsável pela consulta em algum banco de dados e pela carga dos mesmos no formato esperado pelo Javascript e na estrutura esperada pelo HyperCube.
	
	Sobre o formato dos dados, como a aplicação trabalha no formato JSON e o Hypercube precisa de uma estrutura de dados específica, uma excelente abordagem é utilizar um banco de dados NoSQL, que são bancos de dados orientados a documentos, diferente do modelo tradicional que são bancos de dados relacional.
	
	Existem bancos de dados NoSQL que já trabalham no formato JSON como o MongoDB e CouchDB.
	Seria possível armazenar nestes bancos de dados documentos já na estrutura de dados esperada pela aplicação para a geração do cubo de dados.
	Optando pelo uso do CouchDB, abre-se uma oportunidade diferente. Como este possui uma API totalmente baseada no protocolo HTTP, seria possível que o consumo fosse feito diretamente nele, sem a necessidade de outro serviço REST.

	Outra abordagem interessante seria manter o dado em tempo real via WebSocket, onde a aplicação se increveria em uma fila e receberia eventos que poderiam ser utilizados para atualizar os dashboards das páginas de análise.
	Como sugestão, a ferramenta RabbitMQ poderia ser utilizada, pois é uma relativamente fácil de usar, além de possuir plugins que facilitam a integração com sistemas.

\section{Considerações Finais}

	\hl{Pendente...} 

\begin{comment}

	O objetivo deste trabalho era propor um sistema de informação especialista em estatística com algumas características específicas. Entre elas está a centralização do mecanismo de manipulação de dados e a análise dos mesmos diretamente na interface, trazendo consigo uma abordagem diferente no que diz respeito a filtros e segmentações em cubo de dados OLAP, e o uso de ferramentas e tecnologias modernas em sua arquitetura beneficiando e enriquecendo o seu desenvolvimento.
	
	Acredito ter sido feliz na escolha do tema, tentando trazer algo inovador e agregando novos conhecimentos ao currículo. A criação do Statz foi uma experiência muito positiva, seu desenvolvimento trouxe a oportunidade de aprofundar estudos e realizar provas de conceito das ferramentas e tecnologias escolhidas, resultando ainda em uma excelente ferramenta de análise de dados estatísticos.
	
	Tendo em vista o objetivo alcançado, a ideia é aproveitar o Statz em situações mais profissionais, onde a análise dos dados seja útil na tomada de decisões servindo como ferramenta essencial para competitividade no mercado.
	
	Em relação aos próximos passos do Statz, pretende-se evoluir ainda mais o sistema no front-end, considerando a atualização do cubo de dados em tempo real através do recurso WebSocket presente no HTML 5 e suportado por navegadores modernos. Outro ponto importante a evoluir é o uso de banco de dados na carga do cubo de dados para a interface. Não foi implementado neste momento, mas é interessante que seja possível, de preferência um banco de dados não-relacional.
	
	Mobile
	
	Recomendo a utilização do Statz no meio corporativo. Colocando-o em ambiente de produção será importante para sua evoluição, seja aprimorando a arquitetura ou na adaptação a novos modelos de negócio.
\end{comment}

\bibliographystyle{sbc}
\bibliography{artigo-rafael-oliveira}

\end{document}